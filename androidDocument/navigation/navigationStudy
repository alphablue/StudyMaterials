백 스택을 변경하는 작업은 새 대상을 스택 맨 위로 푸시하거나 스택에서 최상위 대상을 팝하여 항상 스택 맨 위에서 작동합니다. 대상으로 이동하면 해당 대상이 스택 맨 위에 푸시됩니다.

navigation의 기본 구성요소

* Navigation Graph
-> xml 리소스가 포함된 것

* NavHost
-> xml 의 fragmentContainer 에서는 navHostFragment 가 구현되어 있고 그것을 활용해 navHost를 얻을 수 있다.
이건 그래프의 목적지를 표시하는 빈 컨테이너이다.

xml 에서의 구현

<androidx.fragment.app.FragmentContainerView
        android:id="@+id/nav_host_fragment"
        android:name="androidx.navigation.fragment.NavHostFragment" // 이 부분이 navHostFragment 를 구현한 것
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"

        app:defaultNavHost="true"
        app:navGraph="@navigation/nav_graph" />


* NavController
-> 앱 내에 이동(탐색)을 관리하는 개체


2022. 7. 18.

shared viewmodel Across fragments 

>> 이 프로젝트에서 알게된 정보

1) 네비게이션 등록을 할 때 mainActivity 는 컨테이너 일 뿐 뷰를 직접 그리면 안된다.

2) setupActionBarwithNavController 를 사용 할 때는 label 을 맞춰야지 up 버튼의 네비게이션이 정상 작동한다.

3) const val 는 컴파일 타임에 정의가 되며 수정이 불가능한 객체이다.

4) data binding 을 사용 할 때는 꼭 DataBindingUtil 을 사용할 필요는 없다. 뷰 바인딩 하듯이 인플레이트 해도
사용이 가능하다.

5) data binding 에 viewmodel 을 적용 하고자 한다면 lifecycleowner 를 등록 해줘야 한다.
binding?.apply {
            // Specify the fragment as the lifecycle owner
            lifecycleOwner = viewLifecycleOwner

            // Assign the view model to a property in the binding class
            viewModel = sharedViewModel

            // Assign the fragment
            flavorFragment = this@FlavorFragment
        }

이 예제에서 사용된 방식을 살펴보면 위와 같다.

 6) calendar 객체를 활용하면 날짜를 쉽게 표현 할 수 있다. 이 프로젝트에서 사용된 예는 현재 날짜 포함한 4일의 정보를 가져 오는 방법을
 사용 했다. 

 private fun getPickupOptions(): List<String> {
        val options = mutableListOf<String>()
        val formatter = SimpleDateFormat("E MMM d", Locale.getDefault())
        val calendar = Calendar.getInstance()
        repeat(4) {
            options.add(formatter.format(calendar.time))
            calendar.add(Calendar.DATE, 1)
        }
        return options
    }

위의 코드에서 처럼 calendar 에 날짜를 하나씩 더해사면서 표현을 했다. SimpleDateFormat 에 대한 정보는 공식 자료에서 제공하는 링크를 첨부 할 것.
-> https://developer.android.com/reference/java/text/SimpleDateFormat?authuser=2#date-and-time-patterns

7) NumberFormat 을 활용하면 설정한 지역에 맞는 통화 화폐 단위를 보여줄 수 있다.

val price: LiveData<String> = Transformations.map(_price) {
        // Format the price into the local currency and return this as LiveData<String>
        NumberFormat.getCurrencyInstance().format(it)
    }

위의 코드에서는 기기의 설정 값을 토대로 보여주는 방법을 취하고 있다.